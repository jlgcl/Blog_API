Use routing.js (similar to catalog.js) to handle routes to controllers
*TIP: any GET renders would be handled by the frontend. Backend should support database and POST controls.


STATUS:
    - test JWT authenticate for user delete
    - consolidate post route files
    - move onto frontend
    - test login - COMPLETE
    - logout - COMPLETE
    - figure out how to setup database for published vs. unpublished posts - COMPLETE
        A) model property - status enum
    - create a control for privileged users: update, delete, publish posts - COMPLETE
    - post GET should only show published posts; unpublished post GET should onyl show unpublished posts - COMPLETE

    ERRORS:
        - 404 error when posting to anywhere using Postman (request passes through the port fine, but response is error)
            - running the router cod through app.post() works, but not through router.post().
            SOLVED) use app.use(method) since the url is already defined in router.post() in the module.
        - Error [ERR_HTTP_HEADERS_SENT]: Cannot set headers after they are sent to the client
            SOLVED) https://stackoverflow.com/questions/52122272/err-http-headers-sent-cannot-set-headers-after-they-are-sent-to-the-client 
        - sign up fails (!errors.isEmpty())
            SOLVED) .isLength({min: 0}), not min: 1 & Postman request must be: x-www.form-urlencoded, NOT form-data
        - "locals" authentication error - in app.js, passport.js must be required as "./passport", not "passport" since this will conflict with the passportJS dependency.
        - at login POST, user: "false" - STRUGGLING***
            SOLVED) password shouldn't be passed to User.findOne() in passport.js LocalStrategy to find a matching user since passport is 'bcrypted'. Password is found using bcrypt.compare() instead.
        - Expected "payload" to be a plain object
            SOLVED) https://stackoverflow.com/questions/52781477/expected-payload-to-be-a-plain-object-mean 
        - For post update, I had to use findById(... (err, results)), NOT .then().



1) sign-up username and password (use bcrypt)
    - assign an ID for each user at sign-up using uuid - this will be used for JWTStrategy authentication (jwtpayLoad.id vs. user.id)
2) login fields and authentication (LocalStrategy) & JWT tokens
    - assign JWT token using jwt.sign(payload, "secretKey")
        - one option is to assign different tokens in passport.authenticate() for admin vs. public user
        - another (preferred) option is to have JWT only assigned & verified for the privileged user - but we won't be able to extract payload/user info for other purposes (i.e. creating a post)
            - we would instead use user IDs to identify and obtain user information from the database (like typical locallibrary project .findOneById() controls) OR use req.user in sessions.
                - this is preferred since when calling verifyToken() middleware in the '/post' POST control, we MUST have a token & may not be able to have two tokens as a parameter
    - keep user in current session using express session & serialize (to use req.user as logged-in user) - include the codes in app.js? or passport.js?
3) models: user (id, username, password), post (includes: title, message, date)
    - ONLY ADMIN TO DELETE USERS
4) create posts: 
    - create posts:
        - passport.authenticate() & fromAuthHeaderAsBearerToken() for authentication to access restricted routes (jwt tokens act like the "passcodes")
        - verifyToken & jwt.verify() if user information is a potential plan to extract JWT payload info (use req.user instead - see above log-in plan notes)
        - leave username as a stamp and timestamp for every message posted (req.context.me = user[x] was used when a model was already available w/o Mongoose - use req.user instead)
        - uuid OR jwt token OR req.user for user info (see login plan above)
        - save to the Post object (sanitize&verify) w/ URI (using mongoose.save() - req.models.messages.messages[id] method doesn't work since we created a mongo model database)
5) published vs. unpublished posts in database
6) routes and controllers - think RESTful; use Postman & cURL for testing
7) create a second page for authoring and editing your posts - show published vs unpublished posts, a button to publish posts/unpublish posts.
    - use passport-jwt for authentication: privilege to edit/modify/delete/publish the posts (only admin & author - if statements of usernames/passcodes)
    - Delete/Update/access details of posts using URI - url virtual for /:id
    - check if the user is admin through passport.authenticate("jwt") OR the author for this route.
8) in React, obtain all post models containing posts/:id, then use GET for each post with ID to show post details.
9) consolidate all post controls into one postController.js (similar to catalog.js)


STEPS

1) in app.js, layout everything first without the use of app.use() routes.

QUESTIONS

1) how would Express receive the username & password information?
    A) for passport-jwt, React would send username & password values along along with a POST header in a specific route. Passport.authenticate will be initiated then LocalStrategy.

2) in passport.js what is payLoad.id for JWT?
    A) tokens have payloads. Frontend sends a token containing the payload (i.e. username) that was created when assigning a token to the user. ID can be used to search for a matching user in the database.

3) how does app.use('/auth', auth) execute router.post('/log-in')?
    A) auth.js require module.exports for all router.get().
    A) the actual path for login is: /auth/login - app.use('/auth') provides the base URL to extend from.

4) difference between verifyToken() in nodeauthapi VS. fromAuthHeaderAsBearerToken()?
    A) does the same thing (extracts JWT from requests), but fromAuthHeaderAsBearerToken() is used with passport for authentication purpose, whereas verifyToken() is a custom middleware function that can be used anywhere.